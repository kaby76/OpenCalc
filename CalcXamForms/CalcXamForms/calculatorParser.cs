//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from calculator.g4 by ANTLR 4.5.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.3")]
[System.CLSCompliant(false)]
public partial class calculatorParser : Parser {
	public const int
		BYTE_ORDER_MARK=1, NEW_LINE=2, WHITESPACE=3, ABSTRACT=4, ADD=5, ALIAS=6, 
		ARGLIST=7, AS=8, ASCENDING=9, BASE=10, BOOL=11, BREAK=12, BY=13, BYTE=14, 
		CASE=15, CATCH=16, CHAR=17, CHECKED=18, CLASS=19, CONST=20, CONTINUE=21, 
		DECIMAL=22, DEFAULT=23, DELEGATE=24, DESCENDING=25, DO=26, DOUBLE=27, 
		DYNAMIC=28, ELSE=29, ENUM=30, EQUALS=31, EVENT=32, EXPLICIT=33, EXTERN=34, 
		FALSE=35, FINALLY=36, FIXED=37, FLOAT=38, FOR=39, FOREACH=40, FROM=41, 
		GET=42, GOTO=43, GROUP=44, IF=45, IMPLICIT=46, IN=47, INT=48, INTERFACE=49, 
		INTERNAL=50, INTO=51, IS=52, JOIN=53, LET=54, LOCK=55, LONG=56, NAMESPACE=57, 
		NEW=58, NULL=59, OBJECT=60, ON=61, OPERATOR=62, ORDERBY=63, OUT=64, OVERRIDE=65, 
		PARAMS=66, PARTIAL=67, PRIVATE=68, PROTECTED=69, PUBLIC=70, READONLY=71, 
		REF=72, REMOVE=73, RETURN=74, SBYTE=75, SEALED=76, SELECT=77, SET=78, 
		SHORT=79, SIZEOF=80, STACKALLOC=81, STATIC=82, STRING=83, STRUCT=84, SWITCH=85, 
		THIS=86, THROW=87, TRUE=88, TRY=89, TYPEOF=90, UINT=91, ULONG=92, UNCHECKED=93, 
		UNSAFE=94, USHORT=95, USING=96, VIRTUAL=97, VOID=98, VOLATILE=99, WHERE=100, 
		WHILE=101, YIELD=102, IDENTIFIER=103, INTEGER_LITERAL=104, REAL_LITERAL=105, 
		CHARACTER_LITERAL=106, STRING_LITERAL=107, OPEN_BRACE=108, CLOSE_BRACE=109, 
		OPEN_BRACKET=110, CLOSE_BRACKET=111, OPEN_PARENS=112, CLOSE_PARENS=113, 
		DOT=114, COMMA=115, COLON=116, SEMICOLON=117, PLUS=118, MINUS=119, STAR=120, 
		DIV=121, PERCENT=122, AMP=123, BITWISE_OR=124, CARET=125, BANG=126, TILDE=127, 
		ASSIGNMENT=128, LT=129, GT=130, INTERR=131, DOUBLE_COLON=132, OP_COALESCING=133, 
		OP_INC=134, OP_DEC=135, OP_AND=136, OP_OR=137, OP_PTR=138, OP_EQ=139, 
		OP_NE=140, OP_LE=141, OP_GE=142, OP_ADD_ASSIGNMENT=143, OP_SUB_ASSIGNMENT=144, 
		OP_MULT_ASSIGNMENT=145, OP_DIV_ASSIGNMENT=146, OP_MOD_ASSIGNMENT=147, 
		OP_AND_ASSIGNMENT=148, OP_OR_ASSIGNMENT=149, OP_XOR_ASSIGNMENT=150, OP_LEFT_SHIFT=151, 
		OP_LEFT_SHIFT_ASSIGNMENT=152, QUOTE=153, DOUBLE_QUOTE=154, BACK_SLASH=155, 
		DOUBLE_BACK_SLASH=156, SHARP=157;
	public const int
		RULE_identifier = 0, RULE_argument_list = 1, RULE_argument = 2, RULE_argument_name = 3, 
		RULE_argument_value = 4, RULE_expressionResult = 5, RULE_equation = 6, 
		RULE_expression = 7, RULE_multiplyingExpression = 8, RULE_powExpression = 9, 
		RULE_atom = 10, RULE_scientific = 11, RULE_func = 12, RULE_funcname = 13, 
		RULE_relop = 14, RULE_number = 15;
	public static readonly string[] ruleNames = {
		"identifier", "argument_list", "argument", "argument_name", "argument_value", 
		"expressionResult", "equation", "expression", "multiplyingExpression", 
		"powExpression", "atom", "scientific", "func", "funcname", "relop", "number"
	};

	private static readonly string[] _LiteralNames = {
		null, "'\\u00EF\\u00BB\\u00BF'", null, null, "'abstract'", "'add'", "'alias'", 
		"'__arglist'", "'as'", "'ascending'", "'base'", "'bool'", "'break'", "'by'", 
		"'byte'", "'case'", "'catch'", "'char'", "'checked'", "'class'", "'const'", 
		"'continue'", "'decimal'", "'default'", "'delegate'", "'descending'", 
		"'do'", "'double'", "'dynamic'", "'else'", "'enum'", "'equals'", "'event'", 
		"'explicit'", "'extern'", "'false'", "'finally'", "'fixed'", "'float'", 
		"'for'", "'foreach'", "'from'", "'get'", "'goto'", "'group'", "'if'", 
		"'implicit'", "'in'", "'int'", "'interface'", "'internal'", "'into'", 
		"'is'", "'join'", "'let'", "'lock'", "'long'", "'namespace'", "'new'", 
		"'null'", "'object'", "'on'", "'operator'", "'orderby'", "'out'", "'override'", 
		"'params'", "'partial'", "'private'", "'protected'", "'public'", "'readonly'", 
		"'ref'", "'remove'", "'return'", "'sbyte'", "'sealed'", "'select'", "'set'", 
		"'short'", "'sizeof'", "'stackalloc'", "'static'", "'string'", "'struct'", 
		"'switch'", "'this'", "'throw'", "'true'", "'try'", "'typeof'", "'uint'", 
		"'ulong'", "'unchecked'", "'unsafe'", "'ushort'", "'using'", "'virtual'", 
		"'void'", "'volatile'", "'where'", "'while'", "'yield'", null, null, null, 
		null, null, "'{'", "'}'", "'['", "']'", "'('", "')'", "'.'", "','", "':'", 
		"';'", "'+'", "'-'", "'*'", "'/'", "'%'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'='", "'<'", "'>'", "'?'", "'::'", "'??'", "'++'", "'--'", "'&&'", 
		"'||'", "'->'", "'=='", "'!='", "'<='", "'>='", "'+='", "'-='", "'*='", 
		"'/='", "'%='", "'&='", "'|='", "'^='", "'<<'", "'<<='", "'''", "'\"'", 
		"'\\'", "'\\\\'", "'#'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "BYTE_ORDER_MARK", "NEW_LINE", "WHITESPACE", "ABSTRACT", "ADD", 
		"ALIAS", "ARGLIST", "AS", "ASCENDING", "BASE", "BOOL", "BREAK", "BY", 
		"BYTE", "CASE", "CATCH", "CHAR", "CHECKED", "CLASS", "CONST", "CONTINUE", 
		"DECIMAL", "DEFAULT", "DELEGATE", "DESCENDING", "DO", "DOUBLE", "DYNAMIC", 
		"ELSE", "ENUM", "EQUALS", "EVENT", "EXPLICIT", "EXTERN", "FALSE", "FINALLY", 
		"FIXED", "FLOAT", "FOR", "FOREACH", "FROM", "GET", "GOTO", "GROUP", "IF", 
		"IMPLICIT", "IN", "INT", "INTERFACE", "INTERNAL", "INTO", "IS", "JOIN", 
		"LET", "LOCK", "LONG", "NAMESPACE", "NEW", "NULL", "OBJECT", "ON", "OPERATOR", 
		"ORDERBY", "OUT", "OVERRIDE", "PARAMS", "PARTIAL", "PRIVATE", "PROTECTED", 
		"PUBLIC", "READONLY", "REF", "REMOVE", "RETURN", "SBYTE", "SEALED", "SELECT", 
		"SET", "SHORT", "SIZEOF", "STACKALLOC", "STATIC", "STRING", "STRUCT", 
		"SWITCH", "THIS", "THROW", "TRUE", "TRY", "TYPEOF", "UINT", "ULONG", "UNCHECKED", 
		"UNSAFE", "USHORT", "USING", "VIRTUAL", "VOID", "VOLATILE", "WHERE", "WHILE", 
		"YIELD", "IDENTIFIER", "INTEGER_LITERAL", "REAL_LITERAL", "CHARACTER_LITERAL", 
		"STRING_LITERAL", "OPEN_BRACE", "CLOSE_BRACE", "OPEN_BRACKET", "CLOSE_BRACKET", 
		"OPEN_PARENS", "CLOSE_PARENS", "DOT", "COMMA", "COLON", "SEMICOLON", "PLUS", 
		"MINUS", "STAR", "DIV", "PERCENT", "AMP", "BITWISE_OR", "CARET", "BANG", 
		"TILDE", "ASSIGNMENT", "LT", "GT", "INTERR", "DOUBLE_COLON", "OP_COALESCING", 
		"OP_INC", "OP_DEC", "OP_AND", "OP_OR", "OP_PTR", "OP_EQ", "OP_NE", "OP_LE", 
		"OP_GE", "OP_ADD_ASSIGNMENT", "OP_SUB_ASSIGNMENT", "OP_MULT_ASSIGNMENT", 
		"OP_DIV_ASSIGNMENT", "OP_MOD_ASSIGNMENT", "OP_AND_ASSIGNMENT", "OP_OR_ASSIGNMENT", 
		"OP_XOR_ASSIGNMENT", "OP_LEFT_SHIFT", "OP_LEFT_SHIFT_ASSIGNMENT", "QUOTE", 
		"DOUBLE_QUOTE", "BACK_SLASH", "DOUBLE_BACK_SLASH", "SHARP"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "calculator.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public calculatorParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class IdentifierContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(calculatorParser.IDENTIFIER, 0); }
		public ITerminalNode FROM() { return GetToken(calculatorParser.FROM, 0); }
		public ITerminalNode LET() { return GetToken(calculatorParser.LET, 0); }
		public ITerminalNode WHERE() { return GetToken(calculatorParser.WHERE, 0); }
		public ITerminalNode JOIN() { return GetToken(calculatorParser.JOIN, 0); }
		public ITerminalNode ON() { return GetToken(calculatorParser.ON, 0); }
		public ITerminalNode EQUALS() { return GetToken(calculatorParser.EQUALS, 0); }
		public ITerminalNode INTO() { return GetToken(calculatorParser.INTO, 0); }
		public ITerminalNode ORDERBY() { return GetToken(calculatorParser.ORDERBY, 0); }
		public ITerminalNode ASCENDING() { return GetToken(calculatorParser.ASCENDING, 0); }
		public ITerminalNode DESCENDING() { return GetToken(calculatorParser.DESCENDING, 0); }
		public ITerminalNode SELECT() { return GetToken(calculatorParser.SELECT, 0); }
		public ITerminalNode GROUP() { return GetToken(calculatorParser.GROUP, 0); }
		public ITerminalNode BY() { return GetToken(calculatorParser.BY, 0); }
		public ITerminalNode PARTIAL() { return GetToken(calculatorParser.PARTIAL, 0); }
		public ITerminalNode ALIAS() { return GetToken(calculatorParser.ALIAS, 0); }
		public ITerminalNode YIELD() { return GetToken(calculatorParser.YIELD, 0); }
		public ITerminalNode GET() { return GetToken(calculatorParser.GET, 0); }
		public ITerminalNode SET() { return GetToken(calculatorParser.SET, 0); }
		public ITerminalNode ADD() { return GetToken(calculatorParser.ADD, 0); }
		public ITerminalNode REMOVE() { return GetToken(calculatorParser.REMOVE, 0); }
		public ITerminalNode DYNAMIC() { return GetToken(calculatorParser.DYNAMIC, 0); }
		public ITerminalNode ARGLIST() { return GetToken(calculatorParser.ARGLIST, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 0, RULE_identifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 32;
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ADD) | (1L << ALIAS) | (1L << ARGLIST) | (1L << ASCENDING) | (1L << BY) | (1L << DESCENDING) | (1L << DYNAMIC) | (1L << EQUALS) | (1L << FROM) | (1L << GET) | (1L << GROUP) | (1L << INTO) | (1L << JOIN) | (1L << LET) | (1L << ON) | (1L << ORDERBY))) != 0) || ((((_la - 67)) & ~0x3f) == 0 && ((1L << (_la - 67)) & ((1L << (PARTIAL - 67)) | (1L << (REMOVE - 67)) | (1L << (SELECT - 67)) | (1L << (SET - 67)) | (1L << (WHERE - 67)) | (1L << (YIELD - 67)) | (1L << (IDENTIFIER - 67)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Argument_listContext : ParserRuleContext {
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(calculatorParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(calculatorParser.COMMA, i);
		}
		public Argument_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterArgument_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitArgument_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Argument_listContext argument_list() {
		Argument_listContext _localctx = new Argument_listContext(Context, State);
		EnterRule(_localctx, 2, RULE_argument_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 34; argument();
			State = 39;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 35; Match(COMMA);
				State = 36; argument();
				}
				}
				State = 41;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		public Argument_valueContext argument_value() {
			return GetRuleContext<Argument_valueContext>(0);
		}
		public Argument_nameContext argument_name() {
			return GetRuleContext<Argument_nameContext>(0);
		}
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 4, RULE_argument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 43;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				{
				State = 42; argument_name();
				}
				break;
			}
			State = 45; argument_value();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Argument_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(calculatorParser.COLON, 0); }
		public Argument_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterArgument_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitArgument_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Argument_nameContext argument_name() {
		Argument_nameContext _localctx = new Argument_nameContext(Context, State);
		EnterRule(_localctx, 6, RULE_argument_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 47; identifier();
			State = 48; Match(COLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Argument_valueContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Argument_valueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument_value; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterArgument_value(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitArgument_value(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument_value(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Argument_valueContext argument_value() {
		Argument_valueContext _localctx = new Argument_valueContext(Context, State);
		EnterRule(_localctx, 8, RULE_argument_value);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 50; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionResultContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASSIGNMENT() { return GetToken(calculatorParser.ASSIGNMENT, 0); }
		public ITerminalNode Eof() { return GetToken(calculatorParser.Eof, 0); }
		public ExpressionResultContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionResult; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterExpressionResult(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitExpressionResult(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionResult(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionResultContext expressionResult() {
		ExpressionResultContext _localctx = new ExpressionResultContext(Context, State);
		EnterRule(_localctx, 10, RULE_expressionResult);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 52; expression();
			State = 53; Match(ASSIGNMENT);
			State = 54; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EquationContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public RelopContext relop() {
			return GetRuleContext<RelopContext>(0);
		}
		public EquationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterEquation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitEquation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EquationContext equation() {
		EquationContext _localctx = new EquationContext(Context, State);
		EnterRule(_localctx, 12, RULE_equation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 56; expression();
			State = 57; relop();
			State = 58; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public MultiplyingExpressionContext[] multiplyingExpression() {
			return GetRuleContexts<MultiplyingExpressionContext>();
		}
		public MultiplyingExpressionContext multiplyingExpression(int i) {
			return GetRuleContext<MultiplyingExpressionContext>(i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(calculatorParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(calculatorParser.PLUS, i);
		}
		public ITerminalNode[] MINUS() { return GetTokens(calculatorParser.MINUS); }
		public ITerminalNode MINUS(int i) {
			return GetToken(calculatorParser.MINUS, i);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 14, RULE_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 60; multiplyingExpression();
			State = 65;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 61;
					_la = TokenStream.La(1);
					if ( !(_la==PLUS || _la==MINUS) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					State = 62; multiplyingExpression();
					}
					} 
				}
				State = 67;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplyingExpressionContext : ParserRuleContext {
		public PowExpressionContext[] powExpression() {
			return GetRuleContexts<PowExpressionContext>();
		}
		public PowExpressionContext powExpression(int i) {
			return GetRuleContext<PowExpressionContext>(i);
		}
		public ITerminalNode[] STAR() { return GetTokens(calculatorParser.STAR); }
		public ITerminalNode STAR(int i) {
			return GetToken(calculatorParser.STAR, i);
		}
		public ITerminalNode[] DIV() { return GetTokens(calculatorParser.DIV); }
		public ITerminalNode DIV(int i) {
			return GetToken(calculatorParser.DIV, i);
		}
		public MultiplyingExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplyingExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterMultiplyingExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitMultiplyingExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplyingExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplyingExpressionContext multiplyingExpression() {
		MultiplyingExpressionContext _localctx = new MultiplyingExpressionContext(Context, State);
		EnterRule(_localctx, 16, RULE_multiplyingExpression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 68; powExpression();
			State = 73;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 69;
					_la = TokenStream.La(1);
					if ( !(_la==STAR || _la==DIV) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					State = 70; powExpression();
					}
					} 
				}
				State = 75;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PowExpressionContext : ParserRuleContext {
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public ITerminalNode CARET() { return GetToken(calculatorParser.CARET, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public PowExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_powExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterPowExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitPowExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPowExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PowExpressionContext powExpression() {
		PowExpressionContext _localctx = new PowExpressionContext(Context, State);
		EnterRule(_localctx, 18, RULE_powExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 76; atom();
			State = 79;
			_la = TokenStream.La(1);
			if (_la==CARET) {
				{
				State = 77; Match(CARET);
				State = 78; expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public ScientificContext scientific() {
			return GetRuleContext<ScientificContext>(0);
		}
		public ITerminalNode OPEN_PARENS() { return GetToken(calculatorParser.OPEN_PARENS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CLOSE_PARENS() { return GetToken(calculatorParser.CLOSE_PARENS, 0); }
		public FuncContext func() {
			return GetRuleContext<FuncContext>(0);
		}
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 20, RULE_atom);
		try {
			State = 87;
			switch (TokenStream.La(1)) {
			case INTEGER_LITERAL:
			case REAL_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 81; scientific();
				}
				break;
			case OPEN_PARENS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 82; Match(OPEN_PARENS);
				State = 83; expression();
				State = 84; Match(CLOSE_PARENS);
				}
				break;
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 86; func();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScientificContext : ParserRuleContext {
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ScientificContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scientific; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterScientific(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitScientific(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScientific(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScientificContext scientific() {
		ScientificContext _localctx = new ScientificContext(Context, State);
		EnterRule(_localctx, 22, RULE_scientific);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 89; number();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncContext : ParserRuleContext {
		public FuncnameContext funcname() {
			return GetRuleContext<FuncnameContext>(0);
		}
		public ITerminalNode OPEN_PARENS() { return GetToken(calculatorParser.OPEN_PARENS, 0); }
		public ITerminalNode CLOSE_PARENS() { return GetToken(calculatorParser.CLOSE_PARENS, 0); }
		public Argument_listContext argument_list() {
			return GetRuleContext<Argument_listContext>(0);
		}
		public FuncContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_func; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterFunc(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitFunc(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunc(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncContext func() {
		FuncContext _localctx = new FuncContext(Context, State);
		EnterRule(_localctx, 24, RULE_func);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 91; funcname();
			State = 92; Match(OPEN_PARENS);
			State = 94;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ADD) | (1L << ALIAS) | (1L << ARGLIST) | (1L << ASCENDING) | (1L << BY) | (1L << DESCENDING) | (1L << DYNAMIC) | (1L << EQUALS) | (1L << FROM) | (1L << GET) | (1L << GROUP) | (1L << INTO) | (1L << JOIN) | (1L << LET) | (1L << ON) | (1L << ORDERBY))) != 0) || ((((_la - 67)) & ~0x3f) == 0 && ((1L << (_la - 67)) & ((1L << (PARTIAL - 67)) | (1L << (REMOVE - 67)) | (1L << (SELECT - 67)) | (1L << (SET - 67)) | (1L << (WHERE - 67)) | (1L << (YIELD - 67)) | (1L << (IDENTIFIER - 67)) | (1L << (INTEGER_LITERAL - 67)) | (1L << (REAL_LITERAL - 67)) | (1L << (OPEN_PARENS - 67)))) != 0)) {
				{
				State = 93; argument_list();
				}
			}

			State = 96; Match(CLOSE_PARENS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncnameContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(calculatorParser.IDENTIFIER, 0); }
		public FuncnameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcname; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterFuncname(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitFuncname(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncname(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncnameContext funcname() {
		FuncnameContext _localctx = new FuncnameContext(Context, State);
		EnterRule(_localctx, 26, RULE_funcname);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 98; Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelopContext : ParserRuleContext {
		public ITerminalNode OP_EQ() { return GetToken(calculatorParser.OP_EQ, 0); }
		public ITerminalNode GT() { return GetToken(calculatorParser.GT, 0); }
		public ITerminalNode LT() { return GetToken(calculatorParser.LT, 0); }
		public RelopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterRelop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitRelop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelopContext relop() {
		RelopContext _localctx = new RelopContext(Context, State);
		EnterRule(_localctx, 28, RULE_relop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 100;
			_la = TokenStream.La(1);
			if ( !(((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (LT - 129)) | (1L << (GT - 129)) | (1L << (OP_EQ - 129)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberContext : ParserRuleContext {
		public ITerminalNode INTEGER_LITERAL() { return GetToken(calculatorParser.INTEGER_LITERAL, 0); }
		public ITerminalNode REAL_LITERAL() { return GetToken(calculatorParser.REAL_LITERAL, 0); }
		public NumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_number; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberContext number() {
		NumberContext _localctx = new NumberContext(Context, State);
		EnterRule(_localctx, 30, RULE_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 102;
			_la = TokenStream.La(1);
			if ( !(_la==INTEGER_LITERAL || _la==REAL_LITERAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x9F");
		sb.Append("k\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4");
		sb.Append("\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r");
		sb.Append("\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x3\x2\x3\x2");
		sb.Append("\x3\x3\x3\x3\x3\x3\a\x3(\n\x3\f\x3\xE\x3+\v\x3\x3\x4\x5\x4.");
		sb.Append("\n\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5\x3\x6\x3\x6\x3\a\x3\a\x3");
		sb.Append("\a\x3\a\x3\b\x3\b\x3\b\x3\b\x3\t\x3\t\x3\t\a\t\x42\n\t\f\t\xE");
		sb.Append("\t\x45\v\t\x3\n\x3\n\x3\n\a\nJ\n\n\f\n\xE\nM\v\n\x3\v\x3\v\x3");
		sb.Append("\v\x5\vR\n\v\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x5\fZ\n\f\x3\r\x3");
		sb.Append("\r\x3\xE\x3\xE\x3\xE\x5\xE\x61\n\xE\x3\xE\x3\xE\x3\xF\x3\xF");
		sb.Append("\x3\x10\x3\x10\x3\x11\x3\x11\x3\x11\x2\x2\x12\x2\x4\x6\b\n\f");
		sb.Append("\xE\x10\x12\x14\x16\x18\x1A\x1C\x1E \x2\a\x13\x2\a\t\v\v\xF");
		sb.Append("\xF\x1B\x1B\x1E\x1E!!+,..\x35\x35\x37\x38??\x41\x41\x45\x45");
		sb.Append("KKOP\x66\x66hi\x3\x2xy\x3\x2z{\x4\x2\x83\x84\x8D\x8D\x3\x2j");
		sb.Append("k\x62\x2\"\x3\x2\x2\x2\x4$\x3\x2\x2\x2\x6-\x3\x2\x2\x2\b\x31");
		sb.Append("\x3\x2\x2\x2\n\x34\x3\x2\x2\x2\f\x36\x3\x2\x2\x2\xE:\x3\x2\x2");
		sb.Append("\x2\x10>\x3\x2\x2\x2\x12\x46\x3\x2\x2\x2\x14N\x3\x2\x2\x2\x16");
		sb.Append("Y\x3\x2\x2\x2\x18[\x3\x2\x2\x2\x1A]\x3\x2\x2\x2\x1C\x64\x3\x2");
		sb.Append("\x2\x2\x1E\x66\x3\x2\x2\x2 h\x3\x2\x2\x2\"#\t\x2\x2\x2#\x3\x3");
		sb.Append("\x2\x2\x2$)\x5\x6\x4\x2%&\au\x2\x2&(\x5\x6\x4\x2\'%\x3\x2\x2");
		sb.Append("\x2(+\x3\x2\x2\x2)\'\x3\x2\x2\x2)*\x3\x2\x2\x2*\x5\x3\x2\x2");
		sb.Append("\x2+)\x3\x2\x2\x2,.\x5\b\x5\x2-,\x3\x2\x2\x2-.\x3\x2\x2\x2.");
		sb.Append("/\x3\x2\x2\x2/\x30\x5\n\x6\x2\x30\a\x3\x2\x2\x2\x31\x32\x5\x2");
		sb.Append("\x2\x2\x32\x33\av\x2\x2\x33\t\x3\x2\x2\x2\x34\x35\x5\x10\t\x2");
		sb.Append("\x35\v\x3\x2\x2\x2\x36\x37\x5\x10\t\x2\x37\x38\a\x82\x2\x2\x38");
		sb.Append("\x39\a\x2\x2\x3\x39\r\x3\x2\x2\x2:;\x5\x10\t\x2;<\x5\x1E\x10");
		sb.Append("\x2<=\x5\x10\t\x2=\xF\x3\x2\x2\x2>\x43\x5\x12\n\x2?@\t\x3\x2");
		sb.Append("\x2@\x42\x5\x12\n\x2\x41?\x3\x2\x2\x2\x42\x45\x3\x2\x2\x2\x43");
		sb.Append("\x41\x3\x2\x2\x2\x43\x44\x3\x2\x2\x2\x44\x11\x3\x2\x2\x2\x45");
		sb.Append("\x43\x3\x2\x2\x2\x46K\x5\x14\v\x2GH\t\x4\x2\x2HJ\x5\x14\v\x2");
		sb.Append("IG\x3\x2\x2\x2JM\x3\x2\x2\x2KI\x3\x2\x2\x2KL\x3\x2\x2\x2L\x13");
		sb.Append("\x3\x2\x2\x2MK\x3\x2\x2\x2NQ\x5\x16\f\x2OP\a\x7F\x2\x2PR\x5");
		sb.Append("\x10\t\x2QO\x3\x2\x2\x2QR\x3\x2\x2\x2R\x15\x3\x2\x2\x2SZ\x5");
		sb.Append("\x18\r\x2TU\ar\x2\x2UV\x5\x10\t\x2VW\as\x2\x2WZ\x3\x2\x2\x2");
		sb.Append("XZ\x5\x1A\xE\x2YS\x3\x2\x2\x2YT\x3\x2\x2\x2YX\x3\x2\x2\x2Z\x17");
		sb.Append("\x3\x2\x2\x2[\\\x5 \x11\x2\\\x19\x3\x2\x2\x2]^\x5\x1C\xF\x2");
		sb.Append("^`\ar\x2\x2_\x61\x5\x4\x3\x2`_\x3\x2\x2\x2`\x61\x3\x2\x2\x2");
		sb.Append("\x61\x62\x3\x2\x2\x2\x62\x63\as\x2\x2\x63\x1B\x3\x2\x2\x2\x64");
		sb.Append("\x65\ai\x2\x2\x65\x1D\x3\x2\x2\x2\x66g\t\x5\x2\x2g\x1F\x3\x2");
		sb.Append("\x2\x2hi\t\x6\x2\x2i!\x3\x2\x2\x2\t)-\x43KQY`");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
