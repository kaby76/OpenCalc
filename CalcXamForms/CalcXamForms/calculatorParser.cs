//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from calculator.g4 by ANTLR 4.5.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.3")]
[System.CLSCompliant(false)]
public partial class calculatorParser : Parser {
	public const int
		BYTE_ORDER_MARK=1, NEW_LINE=2, WHITESPACE=3, ABSTRACT=4, ADD=5, ALIAS=6, 
		ARGLIST=7, AS=8, ASCENDING=9, BASE=10, BOOL=11, BREAK=12, BY=13, BYTE=14, 
		CASE=15, CATCH=16, CHAR=17, CHECKED=18, CLASS=19, CONST=20, CONTINUE=21, 
		DECIMAL=22, DEFAULT=23, DELEGATE=24, DESCENDING=25, DO=26, DOUBLE=27, 
		DYNAMIC=28, ELSE=29, ENUM=30, EQUALS=31, EVENT=32, EXPLICIT=33, EXTERN=34, 
		FALSE=35, FINALLY=36, FIXED=37, FLOAT=38, FOR=39, FOREACH=40, FROM=41, 
		GET=42, GOTO=43, GROUP=44, IF=45, IMPLICIT=46, IN=47, INT=48, INTERFACE=49, 
		INTERNAL=50, INTO=51, IS=52, JOIN=53, LET=54, LOCK=55, LONG=56, NAMESPACE=57, 
		NEW=58, NULL=59, OBJECT=60, ON=61, OPERATOR=62, ORDERBY=63, OUT=64, OVERRIDE=65, 
		PARAMS=66, PARTIAL=67, PRIVATE=68, PROTECTED=69, PUBLIC=70, READONLY=71, 
		REF=72, REMOVE=73, RETURN=74, SBYTE=75, SEALED=76, SELECT=77, SET=78, 
		SHORT=79, SIZEOF=80, STACKALLOC=81, STATIC=82, STRING=83, STRUCT=84, SWITCH=85, 
		THIS=86, THROW=87, TRUE=88, TRY=89, TYPEOF=90, UINT=91, ULONG=92, UNCHECKED=93, 
		UNSAFE=94, USHORT=95, USING=96, VIRTUAL=97, VOID=98, VOLATILE=99, WHERE=100, 
		WHILE=101, YIELD=102, IDENTIFIER=103, INTEGER_LITERAL=104, REAL_LITERAL=105, 
		CHARACTER_LITERAL=106, STRING_LITERAL=107, OPEN_BRACE=108, CLOSE_BRACE=109, 
		OPEN_BRACKET=110, CLOSE_BRACKET=111, OPEN_PARENS=112, CLOSE_PARENS=113, 
		DOT=114, COMMA=115, COLON=116, SEMICOLON=117, PLUS=118, MINUS=119, STAR=120, 
		DIV=121, PERCENT=122, AMP=123, BITWISE_OR=124, CARET=125, BANG=126, TILDE=127, 
		ASSIGNMENT=128, LT=129, GT=130, INTERR=131, DOUBLE_COLON=132, OP_COALESCING=133, 
		OP_INC=134, OP_DEC=135, OP_AND=136, OP_OR=137, OP_PTR=138, OP_EQ=139, 
		OP_NE=140, OP_LE=141, OP_GE=142, OP_ADD_ASSIGNMENT=143, OP_SUB_ASSIGNMENT=144, 
		OP_MULT_ASSIGNMENT=145, OP_DIV_ASSIGNMENT=146, OP_MOD_ASSIGNMENT=147, 
		OP_AND_ASSIGNMENT=148, OP_OR_ASSIGNMENT=149, OP_XOR_ASSIGNMENT=150, OP_LEFT_SHIFT=151, 
		OP_LEFT_SHIFT_ASSIGNMENT=152, QUOTE=153, DOUBLE_QUOTE=154, BACK_SLASH=155, 
		DOUBLE_BACK_SLASH=156, SHARP=157;
	public const int
		RULE_expressionResult = 0, RULE_equation = 1, RULE_expression = 2, RULE_multiplyingExpression = 3, 
		RULE_powExpression = 4, RULE_atom = 5, RULE_scientific = 6, RULE_relop = 7, 
		RULE_number = 8;
	public static readonly string[] ruleNames = {
		"expressionResult", "equation", "expression", "multiplyingExpression", 
		"powExpression", "atom", "scientific", "relop", "number"
	};

	private static readonly string[] _LiteralNames = {
		null, "'\\u00EF\\u00BB\\u00BF'", null, null, "'abstract'", "'add'", "'alias'", 
		"'__arglist'", "'as'", "'ascending'", "'base'", "'bool'", "'break'", "'by'", 
		"'byte'", "'case'", "'catch'", "'char'", "'checked'", "'class'", "'const'", 
		"'continue'", "'decimal'", "'default'", "'delegate'", "'descending'", 
		"'do'", "'double'", "'dynamic'", "'else'", "'enum'", "'equals'", "'event'", 
		"'explicit'", "'extern'", "'false'", "'finally'", "'fixed'", "'float'", 
		"'for'", "'foreach'", "'from'", "'get'", "'goto'", "'group'", "'if'", 
		"'implicit'", "'in'", "'int'", "'interface'", "'internal'", "'into'", 
		"'is'", "'join'", "'let'", "'lock'", "'long'", "'namespace'", "'new'", 
		"'null'", "'object'", "'on'", "'operator'", "'orderby'", "'out'", "'override'", 
		"'params'", "'partial'", "'private'", "'protected'", "'public'", "'readonly'", 
		"'ref'", "'remove'", "'return'", "'sbyte'", "'sealed'", "'select'", "'set'", 
		"'short'", "'sizeof'", "'stackalloc'", "'static'", "'string'", "'struct'", 
		"'switch'", "'this'", "'throw'", "'true'", "'try'", "'typeof'", "'uint'", 
		"'ulong'", "'unchecked'", "'unsafe'", "'ushort'", "'using'", "'virtual'", 
		"'void'", "'volatile'", "'where'", "'while'", "'yield'", null, null, null, 
		null, null, "'{'", "'}'", "'['", "']'", "'('", "')'", "'.'", "','", "':'", 
		"';'", "'+'", "'-'", "'*'", "'/'", "'%'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'='", "'<'", "'>'", "'?'", "'::'", "'??'", "'++'", "'--'", "'&&'", 
		"'||'", "'->'", "'=='", "'!='", "'<='", "'>='", "'+='", "'-='", "'*='", 
		"'/='", "'%='", "'&='", "'|='", "'^='", "'<<'", "'<<='", "'''", "'\"'", 
		"'\\'", "'\\\\'", "'#'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "BYTE_ORDER_MARK", "NEW_LINE", "WHITESPACE", "ABSTRACT", "ADD", 
		"ALIAS", "ARGLIST", "AS", "ASCENDING", "BASE", "BOOL", "BREAK", "BY", 
		"BYTE", "CASE", "CATCH", "CHAR", "CHECKED", "CLASS", "CONST", "CONTINUE", 
		"DECIMAL", "DEFAULT", "DELEGATE", "DESCENDING", "DO", "DOUBLE", "DYNAMIC", 
		"ELSE", "ENUM", "EQUALS", "EVENT", "EXPLICIT", "EXTERN", "FALSE", "FINALLY", 
		"FIXED", "FLOAT", "FOR", "FOREACH", "FROM", "GET", "GOTO", "GROUP", "IF", 
		"IMPLICIT", "IN", "INT", "INTERFACE", "INTERNAL", "INTO", "IS", "JOIN", 
		"LET", "LOCK", "LONG", "NAMESPACE", "NEW", "NULL", "OBJECT", "ON", "OPERATOR", 
		"ORDERBY", "OUT", "OVERRIDE", "PARAMS", "PARTIAL", "PRIVATE", "PROTECTED", 
		"PUBLIC", "READONLY", "REF", "REMOVE", "RETURN", "SBYTE", "SEALED", "SELECT", 
		"SET", "SHORT", "SIZEOF", "STACKALLOC", "STATIC", "STRING", "STRUCT", 
		"SWITCH", "THIS", "THROW", "TRUE", "TRY", "TYPEOF", "UINT", "ULONG", "UNCHECKED", 
		"UNSAFE", "USHORT", "USING", "VIRTUAL", "VOID", "VOLATILE", "WHERE", "WHILE", 
		"YIELD", "IDENTIFIER", "INTEGER_LITERAL", "REAL_LITERAL", "CHARACTER_LITERAL", 
		"STRING_LITERAL", "OPEN_BRACE", "CLOSE_BRACE", "OPEN_BRACKET", "CLOSE_BRACKET", 
		"OPEN_PARENS", "CLOSE_PARENS", "DOT", "COMMA", "COLON", "SEMICOLON", "PLUS", 
		"MINUS", "STAR", "DIV", "PERCENT", "AMP", "BITWISE_OR", "CARET", "BANG", 
		"TILDE", "ASSIGNMENT", "LT", "GT", "INTERR", "DOUBLE_COLON", "OP_COALESCING", 
		"OP_INC", "OP_DEC", "OP_AND", "OP_OR", "OP_PTR", "OP_EQ", "OP_NE", "OP_LE", 
		"OP_GE", "OP_ADD_ASSIGNMENT", "OP_SUB_ASSIGNMENT", "OP_MULT_ASSIGNMENT", 
		"OP_DIV_ASSIGNMENT", "OP_MOD_ASSIGNMENT", "OP_AND_ASSIGNMENT", "OP_OR_ASSIGNMENT", 
		"OP_XOR_ASSIGNMENT", "OP_LEFT_SHIFT", "OP_LEFT_SHIFT_ASSIGNMENT", "QUOTE", 
		"DOUBLE_QUOTE", "BACK_SLASH", "DOUBLE_BACK_SLASH", "SHARP"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "calculator.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public calculatorParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class ExpressionResultContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASSIGNMENT() { return GetToken(calculatorParser.ASSIGNMENT, 0); }
		public ITerminalNode Eof() { return GetToken(calculatorParser.Eof, 0); }
		public ExpressionResultContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionResult; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterExpressionResult(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitExpressionResult(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionResult(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionResultContext expressionResult() {
		ExpressionResultContext _localctx = new ExpressionResultContext(Context, State);
		EnterRule(_localctx, 0, RULE_expressionResult);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 18; expression();
			State = 19; Match(ASSIGNMENT);
			State = 20; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EquationContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public RelopContext relop() {
			return GetRuleContext<RelopContext>(0);
		}
		public EquationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterEquation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitEquation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EquationContext equation() {
		EquationContext _localctx = new EquationContext(Context, State);
		EnterRule(_localctx, 2, RULE_equation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 22; expression();
			State = 23; relop();
			State = 24; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public MultiplyingExpressionContext[] multiplyingExpression() {
			return GetRuleContexts<MultiplyingExpressionContext>();
		}
		public MultiplyingExpressionContext multiplyingExpression(int i) {
			return GetRuleContext<MultiplyingExpressionContext>(i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(calculatorParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(calculatorParser.PLUS, i);
		}
		public ITerminalNode[] MINUS() { return GetTokens(calculatorParser.MINUS); }
		public ITerminalNode MINUS(int i) {
			return GetToken(calculatorParser.MINUS, i);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 4, RULE_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 26; multiplyingExpression();
			State = 31;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,0,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 27;
					_la = TokenStream.La(1);
					if ( !(_la==PLUS || _la==MINUS) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					State = 28; multiplyingExpression();
					}
					} 
				}
				State = 33;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,0,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplyingExpressionContext : ParserRuleContext {
		public PowExpressionContext[] powExpression() {
			return GetRuleContexts<PowExpressionContext>();
		}
		public PowExpressionContext powExpression(int i) {
			return GetRuleContext<PowExpressionContext>(i);
		}
		public ITerminalNode[] STAR() { return GetTokens(calculatorParser.STAR); }
		public ITerminalNode STAR(int i) {
			return GetToken(calculatorParser.STAR, i);
		}
		public ITerminalNode[] DIV() { return GetTokens(calculatorParser.DIV); }
		public ITerminalNode DIV(int i) {
			return GetToken(calculatorParser.DIV, i);
		}
		public MultiplyingExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplyingExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterMultiplyingExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitMultiplyingExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplyingExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplyingExpressionContext multiplyingExpression() {
		MultiplyingExpressionContext _localctx = new MultiplyingExpressionContext(Context, State);
		EnterRule(_localctx, 6, RULE_multiplyingExpression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 34; powExpression();
			State = 39;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 35;
					_la = TokenStream.La(1);
					if ( !(_la==STAR || _la==DIV) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					State = 36; powExpression();
					}
					} 
				}
				State = 41;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PowExpressionContext : ParserRuleContext {
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public ITerminalNode CARET() { return GetToken(calculatorParser.CARET, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public PowExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_powExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterPowExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitPowExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPowExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PowExpressionContext powExpression() {
		PowExpressionContext _localctx = new PowExpressionContext(Context, State);
		EnterRule(_localctx, 8, RULE_powExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 42; atom();
			State = 45;
			_la = TokenStream.La(1);
			if (_la==CARET) {
				{
				State = 43; Match(CARET);
				State = 44; expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public ScientificContext scientific() {
			return GetRuleContext<ScientificContext>(0);
		}
		public ITerminalNode OPEN_PARENS() { return GetToken(calculatorParser.OPEN_PARENS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CLOSE_PARENS() { return GetToken(calculatorParser.CLOSE_PARENS, 0); }
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 10, RULE_atom);
		try {
			State = 52;
			switch (TokenStream.La(1)) {
			case INTEGER_LITERAL:
			case REAL_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 47; scientific();
				}
				break;
			case OPEN_PARENS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 48; Match(OPEN_PARENS);
				State = 49; expression();
				State = 50; Match(CLOSE_PARENS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScientificContext : ParserRuleContext {
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ScientificContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scientific; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterScientific(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitScientific(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScientific(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScientificContext scientific() {
		ScientificContext _localctx = new ScientificContext(Context, State);
		EnterRule(_localctx, 12, RULE_scientific);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 54; number();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelopContext : ParserRuleContext {
		public ITerminalNode OP_EQ() { return GetToken(calculatorParser.OP_EQ, 0); }
		public ITerminalNode GT() { return GetToken(calculatorParser.GT, 0); }
		public ITerminalNode LT() { return GetToken(calculatorParser.LT, 0); }
		public RelopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterRelop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitRelop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelopContext relop() {
		RelopContext _localctx = new RelopContext(Context, State);
		EnterRule(_localctx, 14, RULE_relop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 56;
			_la = TokenStream.La(1);
			if ( !(((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (LT - 129)) | (1L << (GT - 129)) | (1L << (OP_EQ - 129)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberContext : ParserRuleContext {
		public ITerminalNode INTEGER_LITERAL() { return GetToken(calculatorParser.INTEGER_LITERAL, 0); }
		public ITerminalNode REAL_LITERAL() { return GetToken(calculatorParser.REAL_LITERAL, 0); }
		public NumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_number; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberContext number() {
		NumberContext _localctx = new NumberContext(Context, State);
		EnterRule(_localctx, 16, RULE_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 58;
			_la = TokenStream.La(1);
			if ( !(_la==INTEGER_LITERAL || _la==REAL_LITERAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x9F");
		sb.Append("?\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4");
		sb.Append("\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x3\x2\x3\x2\x3\x2\x3\x2\x3");
		sb.Append("\x3\x3\x3\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\a\x4 \n\x4\f\x4\xE\x4");
		sb.Append("#\v\x4\x3\x5\x3\x5\x3\x5\a\x5(\n\x5\f\x5\xE\x5+\v\x5\x3\x6\x3");
		sb.Append("\x6\x3\x6\x5\x6\x30\n\x6\x3\a\x3\a\x3\a\x3\a\x3\a\x5\a\x37\n");
		sb.Append("\a\x3\b\x3\b\x3\t\x3\t\x3\n\x3\n\x3\n\x2\x2\v\x2\x4\x6\b\n\f");
		sb.Append("\xE\x10\x12\x2\x6\x3\x2xy\x3\x2z{\x4\x2\x83\x84\x8D\x8D\x3\x2");
		sb.Append("jk\x39\x2\x14\x3\x2\x2\x2\x4\x18\x3\x2\x2\x2\x6\x1C\x3\x2\x2");
		sb.Append("\x2\b$\x3\x2\x2\x2\n,\x3\x2\x2\x2\f\x36\x3\x2\x2\x2\xE\x38\x3");
		sb.Append("\x2\x2\x2\x10:\x3\x2\x2\x2\x12<\x3\x2\x2\x2\x14\x15\x5\x6\x4");
		sb.Append("\x2\x15\x16\a\x82\x2\x2\x16\x17\a\x2\x2\x3\x17\x3\x3\x2\x2\x2");
		sb.Append("\x18\x19\x5\x6\x4\x2\x19\x1A\x5\x10\t\x2\x1A\x1B\x5\x6\x4\x2");
		sb.Append("\x1B\x5\x3\x2\x2\x2\x1C!\x5\b\x5\x2\x1D\x1E\t\x2\x2\x2\x1E ");
		sb.Append("\x5\b\x5\x2\x1F\x1D\x3\x2\x2\x2 #\x3\x2\x2\x2!\x1F\x3\x2\x2");
		sb.Append("\x2!\"\x3\x2\x2\x2\"\a\x3\x2\x2\x2#!\x3\x2\x2\x2$)\x5\n\x6\x2");
		sb.Append("%&\t\x3\x2\x2&(\x5\n\x6\x2\'%\x3\x2\x2\x2(+\x3\x2\x2\x2)\'\x3");
		sb.Append("\x2\x2\x2)*\x3\x2\x2\x2*\t\x3\x2\x2\x2+)\x3\x2\x2\x2,/\x5\f");
		sb.Append("\a\x2-.\a\x7F\x2\x2.\x30\x5\x6\x4\x2/-\x3\x2\x2\x2/\x30\x3\x2");
		sb.Append("\x2\x2\x30\v\x3\x2\x2\x2\x31\x37\x5\xE\b\x2\x32\x33\ar\x2\x2");
		sb.Append("\x33\x34\x5\x6\x4\x2\x34\x35\as\x2\x2\x35\x37\x3\x2\x2\x2\x36");
		sb.Append("\x31\x3\x2\x2\x2\x36\x32\x3\x2\x2\x2\x37\r\x3\x2\x2\x2\x38\x39");
		sb.Append("\x5\x12\n\x2\x39\xF\x3\x2\x2\x2:;\t\x4\x2\x2;\x11\x3\x2\x2\x2");
		sb.Append("<=\t\x5\x2\x2=\x13\x3\x2\x2\x2\x6!)/\x36");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
