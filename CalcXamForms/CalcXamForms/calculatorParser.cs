//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from calculator.g4 by ANTLR 4.5.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.3")]
[System.CLSCompliant(false)]
public partial class calculatorParser : Parser {
	public const int
		BYTE_ORDER_MARK=1, SINGLE_LINE_DOC_COMMENT=2, DELIMITED_DOC_COMMENT=3, 
		NEW_LINE=4, SINGLE_LINE_COMMENT=5, DELIMITED_COMMENT=6, WHITESPACE=7, 
		ABSTRACT=8, ADD=9, ALIAS=10, ARGLIST=11, AS=12, ASCENDING=13, BASE=14, 
		BOOL=15, BREAK=16, BY=17, BYTE=18, CASE=19, CATCH=20, CHAR=21, CHECKED=22, 
		CLASS=23, CONST=24, CONTINUE=25, DECIMAL=26, DEFAULT=27, DELEGATE=28, 
		DESCENDING=29, DO=30, DOUBLE=31, DYNAMIC=32, ELSE=33, ENUM=34, EQUALS=35, 
		EVENT=36, EXPLICIT=37, EXTERN=38, FALSE=39, FINALLY=40, FIXED=41, FLOAT=42, 
		FOR=43, FOREACH=44, FROM=45, GET=46, GOTO=47, GROUP=48, IF=49, IMPLICIT=50, 
		IN=51, INT=52, INTERFACE=53, INTERNAL=54, INTO=55, IS=56, JOIN=57, LET=58, 
		LOCK=59, LONG=60, NAMESPACE=61, NEW=62, NULL=63, OBJECT=64, ON=65, OPERATOR=66, 
		ORDERBY=67, OUT=68, OVERRIDE=69, PARAMS=70, PARTIAL=71, PRIVATE=72, PROTECTED=73, 
		PUBLIC=74, READONLY=75, REF=76, REMOVE=77, RETURN=78, SBYTE=79, SEALED=80, 
		SELECT=81, SET=82, SHORT=83, SIZEOF=84, STACKALLOC=85, STATIC=86, STRING=87, 
		STRUCT=88, SWITCH=89, THIS=90, THROW=91, TRUE=92, TRY=93, TYPEOF=94, UINT=95, 
		ULONG=96, UNCHECKED=97, UNSAFE=98, USHORT=99, USING=100, VIRTUAL=101, 
		VOID=102, VOLATILE=103, WHERE=104, WHILE=105, YIELD=106, IDENTIFIER=107, 
		INTEGER_LITERAL=108, REAL_LITERAL=109, CHARACTER_LITERAL=110, STRING_LITERAL=111, 
		OPEN_BRACE=112, CLOSE_BRACE=113, OPEN_BRACKET=114, CLOSE_BRACKET=115, 
		OPEN_PARENS=116, CLOSE_PARENS=117, DOT=118, COMMA=119, COLON=120, SEMICOLON=121, 
		PLUS=122, MINUS=123, STAR=124, DIV=125, PERCENT=126, AMP=127, BITWISE_OR=128, 
		CARET=129, BANG=130, TILDE=131, ASSIGNMENT=132, LT=133, GT=134, INTERR=135, 
		DOUBLE_COLON=136, OP_COALESCING=137, OP_INC=138, OP_DEC=139, OP_AND=140, 
		OP_OR=141, OP_PTR=142, OP_EQ=143, OP_NE=144, OP_LE=145, OP_GE=146, OP_ADD_ASSIGNMENT=147, 
		OP_SUB_ASSIGNMENT=148, OP_MULT_ASSIGNMENT=149, OP_DIV_ASSIGNMENT=150, 
		OP_MOD_ASSIGNMENT=151, OP_AND_ASSIGNMENT=152, OP_OR_ASSIGNMENT=153, OP_XOR_ASSIGNMENT=154, 
		OP_LEFT_SHIFT=155, OP_LEFT_SHIFT_ASSIGNMENT=156, QUOTE=157, DOUBLE_QUOTE=158, 
		BACK_SLASH=159, DOUBLE_BACK_SLASH=160, SHARP=161;
	public const int
		RULE_expressionResult = 0, RULE_equation = 1, RULE_expression = 2, RULE_multiplyingExpression = 3, 
		RULE_powExpression = 4, RULE_atom = 5, RULE_scientific = 6, RULE_relop = 7, 
		RULE_number = 8;
	public static readonly string[] ruleNames = {
		"expressionResult", "equation", "expression", "multiplyingExpression", 
		"powExpression", "atom", "scientific", "relop", "number"
	};

	private static readonly string[] _LiteralNames = {
		null, "'\\u00EF\\u00BB\\u00BF'", null, null, null, null, null, null, "'abstract'", 
		"'add'", "'alias'", "'__arglist'", "'as'", "'ascending'", "'base'", "'bool'", 
		"'break'", "'by'", "'byte'", "'case'", "'catch'", "'char'", "'checked'", 
		"'class'", "'const'", "'continue'", "'decimal'", "'default'", "'delegate'", 
		"'descending'", "'do'", "'double'", "'dynamic'", "'else'", "'enum'", "'equals'", 
		"'event'", "'explicit'", "'extern'", "'false'", "'finally'", "'fixed'", 
		"'float'", "'for'", "'foreach'", "'from'", "'get'", "'goto'", "'group'", 
		"'if'", "'implicit'", "'in'", "'int'", "'interface'", "'internal'", "'into'", 
		"'is'", "'join'", "'let'", "'lock'", "'long'", "'namespace'", "'new'", 
		"'null'", "'object'", "'on'", "'operator'", "'orderby'", "'out'", "'override'", 
		"'params'", "'partial'", "'private'", "'protected'", "'public'", "'readonly'", 
		"'ref'", "'remove'", "'return'", "'sbyte'", "'sealed'", "'select'", "'set'", 
		"'short'", "'sizeof'", "'stackalloc'", "'static'", "'string'", "'struct'", 
		"'switch'", "'this'", "'throw'", "'true'", "'try'", "'typeof'", "'uint'", 
		"'ulong'", "'unchecked'", "'unsafe'", "'ushort'", "'using'", "'virtual'", 
		"'void'", "'volatile'", "'where'", "'while'", "'yield'", null, null, null, 
		null, null, "'{'", "'}'", "'['", "']'", "'('", "')'", "'.'", "','", "':'", 
		"';'", "'+'", "'-'", "'*'", "'/'", "'%'", "'&'", "'|'", "'^'", "'!'", 
		"'~'", "'='", "'<'", "'>'", "'?'", "'::'", "'??'", "'++'", "'--'", "'&&'", 
		"'||'", "'->'", "'=='", "'!='", "'<='", "'>='", "'+='", "'-='", "'*='", 
		"'/='", "'%='", "'&='", "'|='", "'^='", "'<<'", "'<<='", "'''", "'\"'", 
		"'\\'", "'\\\\'", "'#'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "BYTE_ORDER_MARK", "SINGLE_LINE_DOC_COMMENT", "DELIMITED_DOC_COMMENT", 
		"NEW_LINE", "SINGLE_LINE_COMMENT", "DELIMITED_COMMENT", "WHITESPACE", 
		"ABSTRACT", "ADD", "ALIAS", "ARGLIST", "AS", "ASCENDING", "BASE", "BOOL", 
		"BREAK", "BY", "BYTE", "CASE", "CATCH", "CHAR", "CHECKED", "CLASS", "CONST", 
		"CONTINUE", "DECIMAL", "DEFAULT", "DELEGATE", "DESCENDING", "DO", "DOUBLE", 
		"DYNAMIC", "ELSE", "ENUM", "EQUALS", "EVENT", "EXPLICIT", "EXTERN", "FALSE", 
		"FINALLY", "FIXED", "FLOAT", "FOR", "FOREACH", "FROM", "GET", "GOTO", 
		"GROUP", "IF", "IMPLICIT", "IN", "INT", "INTERFACE", "INTERNAL", "INTO", 
		"IS", "JOIN", "LET", "LOCK", "LONG", "NAMESPACE", "NEW", "NULL", "OBJECT", 
		"ON", "OPERATOR", "ORDERBY", "OUT", "OVERRIDE", "PARAMS", "PARTIAL", "PRIVATE", 
		"PROTECTED", "PUBLIC", "READONLY", "REF", "REMOVE", "RETURN", "SBYTE", 
		"SEALED", "SELECT", "SET", "SHORT", "SIZEOF", "STACKALLOC", "STATIC", 
		"STRING", "STRUCT", "SWITCH", "THIS", "THROW", "TRUE", "TRY", "TYPEOF", 
		"UINT", "ULONG", "UNCHECKED", "UNSAFE", "USHORT", "USING", "VIRTUAL", 
		"VOID", "VOLATILE", "WHERE", "WHILE", "YIELD", "IDENTIFIER", "INTEGER_LITERAL", 
		"REAL_LITERAL", "CHARACTER_LITERAL", "STRING_LITERAL", "OPEN_BRACE", "CLOSE_BRACE", 
		"OPEN_BRACKET", "CLOSE_BRACKET", "OPEN_PARENS", "CLOSE_PARENS", "DOT", 
		"COMMA", "COLON", "SEMICOLON", "PLUS", "MINUS", "STAR", "DIV", "PERCENT", 
		"AMP", "BITWISE_OR", "CARET", "BANG", "TILDE", "ASSIGNMENT", "LT", "GT", 
		"INTERR", "DOUBLE_COLON", "OP_COALESCING", "OP_INC", "OP_DEC", "OP_AND", 
		"OP_OR", "OP_PTR", "OP_EQ", "OP_NE", "OP_LE", "OP_GE", "OP_ADD_ASSIGNMENT", 
		"OP_SUB_ASSIGNMENT", "OP_MULT_ASSIGNMENT", "OP_DIV_ASSIGNMENT", "OP_MOD_ASSIGNMENT", 
		"OP_AND_ASSIGNMENT", "OP_OR_ASSIGNMENT", "OP_XOR_ASSIGNMENT", "OP_LEFT_SHIFT", 
		"OP_LEFT_SHIFT_ASSIGNMENT", "QUOTE", "DOUBLE_QUOTE", "BACK_SLASH", "DOUBLE_BACK_SLASH", 
		"SHARP"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "calculator.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public calculatorParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class ExpressionResultContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASSIGNMENT() { return GetToken(calculatorParser.ASSIGNMENT, 0); }
		public ExpressionResultContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionResult; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterExpressionResult(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitExpressionResult(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionResult(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionResultContext expressionResult() {
		ExpressionResultContext _localctx = new ExpressionResultContext(Context, State);
		EnterRule(_localctx, 0, RULE_expressionResult);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 18; expression();
			State = 19; Match(ASSIGNMENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EquationContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public RelopContext relop() {
			return GetRuleContext<RelopContext>(0);
		}
		public EquationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterEquation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitEquation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EquationContext equation() {
		EquationContext _localctx = new EquationContext(Context, State);
		EnterRule(_localctx, 2, RULE_equation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 21; expression();
			State = 22; relop();
			State = 23; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public MultiplyingExpressionContext[] multiplyingExpression() {
			return GetRuleContexts<MultiplyingExpressionContext>();
		}
		public MultiplyingExpressionContext multiplyingExpression(int i) {
			return GetRuleContext<MultiplyingExpressionContext>(i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(calculatorParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(calculatorParser.PLUS, i);
		}
		public ITerminalNode[] MINUS() { return GetTokens(calculatorParser.MINUS); }
		public ITerminalNode MINUS(int i) {
			return GetToken(calculatorParser.MINUS, i);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 4, RULE_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 25; multiplyingExpression();
			State = 30;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,0,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 26;
					_la = TokenStream.La(1);
					if ( !(_la==PLUS || _la==MINUS) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					State = 27; multiplyingExpression();
					}
					} 
				}
				State = 32;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,0,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplyingExpressionContext : ParserRuleContext {
		public PowExpressionContext[] powExpression() {
			return GetRuleContexts<PowExpressionContext>();
		}
		public PowExpressionContext powExpression(int i) {
			return GetRuleContext<PowExpressionContext>(i);
		}
		public ITerminalNode[] STAR() { return GetTokens(calculatorParser.STAR); }
		public ITerminalNode STAR(int i) {
			return GetToken(calculatorParser.STAR, i);
		}
		public ITerminalNode[] DIV() { return GetTokens(calculatorParser.DIV); }
		public ITerminalNode DIV(int i) {
			return GetToken(calculatorParser.DIV, i);
		}
		public MultiplyingExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplyingExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterMultiplyingExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitMultiplyingExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplyingExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplyingExpressionContext multiplyingExpression() {
		MultiplyingExpressionContext _localctx = new MultiplyingExpressionContext(Context, State);
		EnterRule(_localctx, 6, RULE_multiplyingExpression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 33; powExpression();
			State = 38;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 34;
					_la = TokenStream.La(1);
					if ( !(_la==STAR || _la==DIV) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					State = 35; powExpression();
					}
					} 
				}
				State = 40;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PowExpressionContext : ParserRuleContext {
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public ITerminalNode CARET() { return GetToken(calculatorParser.CARET, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public PowExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_powExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterPowExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitPowExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPowExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PowExpressionContext powExpression() {
		PowExpressionContext _localctx = new PowExpressionContext(Context, State);
		EnterRule(_localctx, 8, RULE_powExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 41; atom();
			State = 44;
			_la = TokenStream.La(1);
			if (_la==CARET) {
				{
				State = 42; Match(CARET);
				State = 43; expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public ScientificContext scientific() {
			return GetRuleContext<ScientificContext>(0);
		}
		public ITerminalNode OPEN_PARENS() { return GetToken(calculatorParser.OPEN_PARENS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CLOSE_PARENS() { return GetToken(calculatorParser.CLOSE_PARENS, 0); }
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 10, RULE_atom);
		try {
			State = 51;
			switch (TokenStream.La(1)) {
			case INTEGER_LITERAL:
			case REAL_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 46; scientific();
				}
				break;
			case OPEN_PARENS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 47; Match(OPEN_PARENS);
				State = 48; expression();
				State = 49; Match(CLOSE_PARENS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScientificContext : ParserRuleContext {
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ScientificContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scientific; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterScientific(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitScientific(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScientific(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScientificContext scientific() {
		ScientificContext _localctx = new ScientificContext(Context, State);
		EnterRule(_localctx, 12, RULE_scientific);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 53; number();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelopContext : ParserRuleContext {
		public ITerminalNode OP_EQ() { return GetToken(calculatorParser.OP_EQ, 0); }
		public ITerminalNode GT() { return GetToken(calculatorParser.GT, 0); }
		public ITerminalNode LT() { return GetToken(calculatorParser.LT, 0); }
		public RelopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterRelop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitRelop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelopContext relop() {
		RelopContext _localctx = new RelopContext(Context, State);
		EnterRule(_localctx, 14, RULE_relop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 55;
			_la = TokenStream.La(1);
			if ( !(((((_la - 133)) & ~0x3f) == 0 && ((1L << (_la - 133)) & ((1L << (LT - 133)) | (1L << (GT - 133)) | (1L << (OP_EQ - 133)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberContext : ParserRuleContext {
		public ITerminalNode INTEGER_LITERAL() { return GetToken(calculatorParser.INTEGER_LITERAL, 0); }
		public ITerminalNode REAL_LITERAL() { return GetToken(calculatorParser.REAL_LITERAL, 0); }
		public NumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_number; } }
		public override void EnterRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IcalculatorListener typedListener = listener as IcalculatorListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IcalculatorVisitor<TResult> typedVisitor = visitor as IcalculatorVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberContext number() {
		NumberContext _localctx = new NumberContext(Context, State);
		EnterRule(_localctx, 16, RULE_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 57;
			_la = TokenStream.La(1);
			if ( !(_la==INTEGER_LITERAL || _la==REAL_LITERAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\xA3");
		sb.Append(">\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4");
		sb.Append("\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x3\x2\x3\x2\x3\x2\x3\x3\x3");
		sb.Append("\x3\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\a\x4\x1F\n\x4\f\x4\xE\x4\"");
		sb.Append("\v\x4\x3\x5\x3\x5\x3\x5\a\x5\'\n\x5\f\x5\xE\x5*\v\x5\x3\x6\x3");
		sb.Append("\x6\x3\x6\x5\x6/\n\x6\x3\a\x3\a\x3\a\x3\a\x3\a\x5\a\x36\n\a");
		sb.Append("\x3\b\x3\b\x3\t\x3\t\x3\n\x3\n\x3\n\x2\x2\v\x2\x4\x6\b\n\f\xE");
		sb.Append("\x10\x12\x2\x6\x3\x2|}\x3\x2~\x7F\x4\x2\x87\x88\x91\x91\x3\x2");
		sb.Append("no\x38\x2\x14\x3\x2\x2\x2\x4\x17\x3\x2\x2\x2\x6\x1B\x3\x2\x2");
		sb.Append("\x2\b#\x3\x2\x2\x2\n+\x3\x2\x2\x2\f\x35\x3\x2\x2\x2\xE\x37\x3");
		sb.Append("\x2\x2\x2\x10\x39\x3\x2\x2\x2\x12;\x3\x2\x2\x2\x14\x15\x5\x6");
		sb.Append("\x4\x2\x15\x16\a\x86\x2\x2\x16\x3\x3\x2\x2\x2\x17\x18\x5\x6");
		sb.Append("\x4\x2\x18\x19\x5\x10\t\x2\x19\x1A\x5\x6\x4\x2\x1A\x5\x3\x2");
		sb.Append("\x2\x2\x1B \x5\b\x5\x2\x1C\x1D\t\x2\x2\x2\x1D\x1F\x5\b\x5\x2");
		sb.Append("\x1E\x1C\x3\x2\x2\x2\x1F\"\x3\x2\x2\x2 \x1E\x3\x2\x2\x2 !\x3");
		sb.Append("\x2\x2\x2!\a\x3\x2\x2\x2\" \x3\x2\x2\x2#(\x5\n\x6\x2$%\t\x3");
		sb.Append("\x2\x2%\'\x5\n\x6\x2&$\x3\x2\x2\x2\'*\x3\x2\x2\x2(&\x3\x2\x2");
		sb.Append("\x2()\x3\x2\x2\x2)\t\x3\x2\x2\x2*(\x3\x2\x2\x2+.\x5\f\a\x2,");
		sb.Append("-\a\x83\x2\x2-/\x5\x6\x4\x2.,\x3\x2\x2\x2./\x3\x2\x2\x2/\v\x3");
		sb.Append("\x2\x2\x2\x30\x36\x5\xE\b\x2\x31\x32\av\x2\x2\x32\x33\x5\x6");
		sb.Append("\x4\x2\x33\x34\aw\x2\x2\x34\x36\x3\x2\x2\x2\x35\x30\x3\x2\x2");
		sb.Append("\x2\x35\x31\x3\x2\x2\x2\x36\r\x3\x2\x2\x2\x37\x38\x5\x12\n\x2");
		sb.Append("\x38\xF\x3\x2\x2\x2\x39:\t\x4\x2\x2:\x11\x3\x2\x2\x2;<\t\x5");
		sb.Append("\x2\x2<\x13\x3\x2\x2\x2\x6 (.\x35");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
